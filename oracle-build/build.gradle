import groovy.io.FileType

project.version = "2.95.0"
project.description = "Мониторинг"

buildscript {
    dependencies {
        classpath 'org.hidetake:gradle-ssh-plugin:2.0.0'
    }
}

// default defined params
def fileSeparator = File.separator;
def outputDir = "$buildDir/buildDB"
def userOrdering = ["SYSTEM","SYS","TRCARD","ETICKET","GATE"]
def dirOrdering = ["00_BEFORE","01_TYPES","02_PACKAGES","03_PROCEDURES","04_FUNCTIONS","05_VIEWS","06_MVIEWS","07_TRIGGERS","08_PACKAGE_BODIES","09_AFTER"]
def dbDir = "db"
def testDir = "dbtest"
def testResult = "test-results"

// required params
def dbhost = "pinky.tcpatch"
def restorePoint = "CURRENTPATCH"

def rebuildScript = ""


/**
* 
**/
task diffMaster(type:Exec) {
  workingDir '.'
  executable = "git" 
  args = ["diff","--name-status","master", dbDir]
      
  standardOutput = new ByteArrayOutputStream()
  
  ext.files = {
    def files = []
    standardOutput.toString().split("\n").each {
	     if ( it.substring(0,1) == "A" || it.substring(0,1) == "M") { 
		     files << it.substring(2) 
		 }	
	}
	return files
  }
}

task clean << {
	  delete(outputDir)
}

task copyFiles(dependsOn: [diffMaster, clean]) << {
		diffMaster.files().each {
	       def file = it
		   def path = it.substring(0, it.lastIndexOf("/"))
	       copy{
			  from file
			  into "${outputDir}/${path}"			  
	       }		   
	   }
}

task zipTar (type:Tar) {
        //archivePath "${buildDir}/sql/dist"
		archiveName "sql.tar"
		destinationDir new File("${buildDir}/sql/dist")
		from { "${outputDir}" }		 
}


def makeRecompSql(outputDir) {

      File RecompSql = new File(outputDir + "/recompile.sql")
 
      RecompSql << "declare\n"
      RecompSql << "procedure exec_cmd( p\$cmd IN VARCHAR2 )\n"
      RecompSql << "IS\n"
      RecompSql << "BEGIN\n"
      RecompSql << "   execute immediate p\$cmd;\n"
      RecompSql << "exception\n"
      RecompSql << "   when others then\n"
      RecompSql << "      dbms_output.put_line( sqlerrm );\n"
      RecompSql << "END exec_cmd;\n"
      RecompSql << "procedure compile_all(p\$ob_type IN VARCHAR2,\n"
      RecompSql << "         p\$dop IN VARCHAR2 DEFAULT '' )\n"
      RecompSql << "IS\n"
      RecompSql << "begin\n"
      RecompSql << "for c in (\n"
      RecompSql << "select 'alter ' || p\$ob_type || ' '||object_name||' compile'||p\$dop cmd\n"
      RecompSql << "from user_objects\n"
      RecompSql << "where object_type = p\$ob_type || p\$dop\n"
      RecompSql << " and status = 'INVALID'\n"
      RecompSql << ") loop\n"
      RecompSql << "   exec_cmd(c.cmd);\n"
      RecompSql << "end loop;\n"
      RecompSql << "end compile_all;\n"
      RecompSql << "begin\n"
      RecompSql << "   compile_all('TYPE');\n"
      RecompSql << "   compile_all('TYPE',' BODY');\n"
      RecompSql << "   compile_all('VIEW');\n"
      RecompSql << "   compile_all('PACKAGE');\n"
      RecompSql << "   compile_all('PACKAGE',' BODY');\n"
      RecompSql << "   compile_all('FUNCTION');\n"
      RecompSql << "   compile_all('PROCEDURE');\n"
      RecompSql << "   compile_all('TRIGGER');\n"
      RecompSql << "   compile_all('MATERIALIZED VIEW');\n"
      RecompSql << "   compile_all('OPERATOR');\n"
      RecompSql << "for c in (\n"
      RecompSql << "select 'create or replace synonym ' || synonym_name || ' for '||table_owner||'.'||table_name cmd\n"
      RecompSql << "from user_synonyms\n"
      RecompSql << ") loop\n"
      RecompSql << "   exec_cmd(c.cmd);\n"
      RecompSql << "end loop;\n"
      RecompSql << "end;\n"
      RecompSql << "/\n"             
      RecompSql << "set termout on\n"
      RecompSql << "set verify on\n"
      RecompSql << "set heading on\n"             
      RecompSql << "column object_name format A30\n"
      RecompSql << "column object_type format A30\n"             
      RecompSql << "select object_name,object_type from user_objects\n"
      RecompSql << "where status = 'INVALID';\n"

}


task generateBuildScript(dependsOn: copyFiles) << {        

                makeRecompSql(outputDir)
		def doSQL = new File(outputDir + "/do.sql")
		def confSQL = new File(outputDir + "/conf.sql")
		
		doSQL << "SET SERVEROUTPUT ON SIZE 1000000\n"
                doSQL << "SET VERI OFF\n"
		doSQL << "SET FEEDBACK ON\n"
                doSQL << "SET TERMOUT ON\n"
                doSQL << "spool install.log\n"
		doSQL << "\n"
		
		doSQL << "@@conf.sql\n\n"
		  
		def users = []			
		new File(outputDir + "/" + dbDir ).eachDir() { dir -> users += dir.getName() }
		users.sort() { a,b -> userOrdering.reverse().indexOf(b) <=> userOrdering.reverse().indexOf(a) }
				
	        users.each { user ->
	            println "Create script for user " + user
		  
		if (user != "SYS" && user != "SYSTEM") 
			confSQL << "define ${user}_PWD=\"${user}\"\ndefine ${user}_TBS=\"USERS\"\ndefine ${user}_TMP_TBS=\"TEMP\"\n\n"		  

          doSQL << "PROMPT ${user}\n\n"	
		  doSQL << "conn ${user}/${user}@${dbhost}" + ( user == "SYS" ? " AS SYSDBA" : "") + "\n\n"

		  def scriptDirs = []
		  new File(outputDir + "/" + dbDir + "/" + user ).eachDir() { dir -> scriptDirs += dir.getName() }
          scriptDirs.sort() { a,b -> dirOrdering.reverse().indexOf(b) <=> dirOrdering.reverse().indexOf(a) }
		  
		  scriptDirs.each { scriptDir ->
			new File(outputDir + "/" + dbDir + "/" + user + "/" + scriptDir ).eachFileRecurse (FileType.FILES) { userFile ->
				def file = (userFile.absolutePath - new File(outputDir).absolutePath).substring(1).replace(fileSeparator,"/")
				doSQL << "@@${file}\n"
			}
		  }
		  
		  doSQL << "\n\n"
		}				
		
            doSQL << "PROMPT Invalid object after recompiling below:\n"

	        (users - ['SYS', 'SYSTEM']).each { user ->	            
                    doSQL << "PROMPT ${user}:"                                        
                    doSQL << "conn ${user}/${user}@${dbhost}" + ( user == "SYS" ? " AS SYSDBA" : "") + "\n\n"
                    doSQL << "@@recompile.sql\n"
                }                  
		
		doSQL << "spool off\n"
		doSQL << "exit\n"		
}

task build(dependsOn: generateBuildScript) << {	
	println "OK"   
}

task copyInstallTestFiles(type: Copy) {
			  from "dbtest"
			  into "${outputDir}/dbtest"
}

task generateTestBuildScript(dependsOn: copyInstallTestFiles) << {
		def installTestSQL = new File(outputDir + "/installTest.sql")
		def users = []			
		new File(outputDir + "/dbtest").eachDir() { dir -> users += dir.getName() }
		
		installTestSQL << "SET SERVEROUTPUT ON SIZE 1000000\n"
        installTestSQL << "SET VERI OFF\n"
		installTestSQL << "SET FEEDBACK ON\n"
        installTestSQL << "SET TERMOUT ON\n"
        installTestSQL << "spool installTest.log\n"
		installTestSQL << "\n"		
		
		users.each { user ->
			installTestSQL << "conn ${user}/${user}@${dbhost}" + ( user == "SYS" ? " AS SYSDBA" : "") + "\n\n"
			
		    def scriptDirs = []
            new File(outputDir + "/" + testDir + "/" + user ).eachDir() { dir -> scriptDirs += dir.getName() }
            scriptDirs.sort() { a,b -> dirOrdering.reverse().indexOf(b) <=> dirOrdering.reverse().indexOf(a) }
		  
		    scriptDirs.each { scriptDir ->
			   new File(outputDir + "/" + testDir + "/" + user + "/" + scriptDir ).eachFileRecurse (FileType.FILES) { userFile ->
				  def file = (userFile.absolutePath - new File(outputDir).absolutePath).substring(1).replace(fileSeparator,"/")
				  installTestSQL << "@@${file}\n"
			   }
		    }
		
		} 
		installTestSQL << "spool off\n"
		installTestSQL << "exit\n"				
}

apply plugin: "org.hidetake.ssh"

remotes {
    db {
        host = 'host.ru'
        port = 22
        user = 'oracle'
        password = 'oracle'
        knownHosts = allowAnyHosts
		dryRun = true
    }
}

task restoreDB << {
      def sqlCmd2  = "pwd" //echo \$PATH"
	  def sqlCmd = "sqlplus -s / as sysdba << EOF\n"
      sqlCmd += "shutdown immediate\n"
      sqlCmd += "startup mount\n"
      sqlCmd += "flashback database to restore point ${restorePoint}\n"
      sqlCmd += "/\n"
      sqlCmd += "alter database open resetlogs\n"
      sqlCmd += "/\n"
      sqlCmd += "exit\n"
      sqlCmd += "EOF"
	  	  
    ssh.run {
		session(remotes.db) {			
		    execute ("bash flashback.sh ${restorePoint}") { result ->
				println result
			}
		}
    }
}
 

task install(type:Exec, dependsOn: restoreDB) {
  workingDir "${outputDir}"
  executable = "sqlplus" 
  args = ["-s","/nolog","@do"]     
}


task installTest(type:Exec,dependsOn: generateTestBuildScript) {
  workingDir "${outputDir}"
  executable = "sqlplus" 
  //args = ["-s","/nolog","@installTest"]
}

task test << {
    (new File("${buildDir}/${testResult}")).mkdirs()
    def resTest = new File("${buildDir}/${testResult}/test-result.xml")
	resTest << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
	    resTest << "<testsuite name=\"suite 1\" tests=\"1\" skipped=\"0\" failures=\"0\" errors=\"0\" timestamp=\"2016-07-26T03:27:48\" hostname=\"still\" time=\"0.461\">"
		resTest << "<properties/>"
        resTest << "<testcase name=\"case 1\" classname=\"class name\" time=\"0.416\"/>"
        resTest << "<system-out><![CDATA[]]></system-out>"
        resTest << "<system-err><![CDATA[]]></system-err>"
        resTest << "</testsuite>"	
}
